# 代码优化
1. 代码优化：通过程序变换(局部变换和全局变换)来改进程序,称为优化
2. 代码优化的种类
    1. 基本块内优化、全局优化
    2. 公共子表达式删除、复写传播、死代码删除
    3. 循环优化
3. 代码优化的实现方式：数据流分析及其一般框架、循环的识别和分析

## 优化举例（Lecture16）
1. 公共子表达式：P12-17
2. 复写传播：P18-20，**复写传播变换本身并不是优化,但它给其它优化带来机会**
	+ 常量合并(编译时可完成的计算) 
	+ 死代码删除
3. 死代码删除：P21-22，**22为复写传播引起的死代码删除**
4. 循环优化
	1. 代码外提是循环优化的一种。
		+ 例：`while (i <= limit - 2 )...`   
		代码外提后变换成   
				t = limit - 2;   
           	 while (i <= t ) ...
    2. 强度削弱和归纳变量删除
    		j = j * 1
			t4 = 4 * j
			t5 = a[t4]
			if t5 > v goto B3

		1. j 和t4 的值步伐一致地变化，这样的变量叫做归纳变量
		2. 对本例可以先做强度削弱它给删除归纳变量创造机会
			+ 用廉价运算替换（加替换乘）：`t4 = 4 * j` -> `t4 = t4 -4`
			+ 删除归纳变量：`if i >= j goto B6` -> `if t2 >= t4 goto B6`

## 代码优化的实现方式
1. 到达-定值分析
	+ 到达-定值的数据流等式
		+ $gen_B$：B中能到达B的结束点的定值语句
		+ $killB$：整个程序中决不会到达B结束点的定值
		+ IN[B]:能到达B的开始点的定值集合
		+ OUT[B]:能到达B的结束点的定值集合
	+ 两组等式 (根据 gen 和 kill 定义 IN 和 OUT)
		+ IN[B] = $∪_{P是B的前驱}$ OUT[P]
		+ OUT[B] = $gen_B$ ∪ (IN[B] - $kill_B$)
		+ OUT[ENTRY] = Ф
	+ 到达-定值方程组的迭代求解, 最终到达不动点。计算算法：P47，例子在P48-60
2. 活跃变量分析
	+ 定义
		+ x的值在p点开始的某条执行路径上被引用**（在定值被注销之前？）**，则说x在p点活跃,否则称x在p点已经死亡
		+ IN[B]：块B开始点的活跃变量集合
		+ OUT[B]：块B结束点的活跃变量集合
		+ $use_B$：块B中有引用且在引用前无定值的变量集
		+ $def_B$：块B中有定值且该定值前无引用的变量集
	+ 应用
		+ 一种重要应用就是基本块的寄存器分配
    + 活跃变量数据流等式
		+ IN [B] = $use_B$ ∪ (OUT [B] - $def_B$ )
		+ OUT[B] = $∪_{S是B的后继}$ IN [S]
		+ IN [EXIT] = Ф
	+ **和到达-定值等式之间的联系与区别**
		+ 都以集合并算符作为它们的汇合算符
		+ 信息流动方向相反,IN和OUT的作用相互交换
		+ use和def分别取代gen和kill
		+ 仍然需要最小解
3. 可用表达式
	1. 定义：若到点p的每条执行路径都计算x + y,并且计算后没有对x或y赋值,那么称x + y在点p可用
		+ $e\_gen_B$：块B产生的可用表达式集合
		+ $e\_kill_B$：块B注销的可用表达式集合
		+ IN[B]: 块B入口的可用表达式集合
		+ OUT[B]:块B出口的可用表达式集合
	2. 应用
		+ 公共子表达式删除
	3. 数据流等式
		+ OUT[B] = $e\_gen_B$ ∪ ( IN[B] - $e\_kill_B$ )
		+ IN[B] = $∩_{P是B的前驱}$ OUT[P]
		+ IN[ENTRY] = Ф
	4. 同先前的主要区别
		+ 使用∩而不是∪作为这里数据流等式的汇合算符
		+ 求最大解而不是最小解
	+ **基本块生成的表达式 & 基本块杀死的表达式:计算方法在 P84**

## 流图中的循环
1. 概念
	1. 支配结点：若从初始结点起,每条
到达n的路径都要经过d,写成d dom n
	2. 深度优先排序
    3. 回边：如果有a dom b ,那么边b -> a叫做回边
	4. 图的可归约性:如果把一个流图中所有回边删掉后，剩余的图无环，则为可规约流图
	5. 图的深度：深度是在无环路径上的最
大后撤边数
2. 自然循环
	1. 自然循环的性质：
		+ 有唯一的入口结点，叫做首结点，首结点支配该循环中所有结点
		+ 至少存在一条回边进入该循环首结点
	2. **回边n -> d确定的自然循环**
		+ **d加上不经过d能到达n的所有结点**
		+ 结点d是该循环的首结点
3. 内循环
	+ 若一个循环的结点集合是另一个循环的结点集合的子集
	+ 两个循环有相同的首结点，但并非一个结点集是另一个的子集，则看成一个循环












