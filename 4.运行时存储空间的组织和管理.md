# 运行时存储空间的组织和管理
+ 过程的活动(activation): 过程的一次执行
+ 活动记录：过程的活动需要可执行代码和存放所
需信息的存储空间，后者称为活动记录


1. 名字的作用域和绑定：书本 P172
2. 活动记录结构：书本 P174，包括临时数据、局部数据、保存的机器状态、访问链、控制链、返回值和参数；

## 全局栈式存储分配（页码默认指书本）
1. 运行时内存的划分：P177
2. **调用序列：P180-181**
3. 栈内活动记录的图示：P181-182 图 6.10\6.11
4. <font color=red>**P181 例 6.4 C语言函数生成的汇编代码！！！**</font>
5. **scanf 的可变参数：Lecture14 P63-64**
6. 如何在栈上布局可变长的数组?
	+ 先分配存放数组指针的单元,对数组的访问通过指针间接访问
	+ 运行时,这些指针指向分配在栈顶的数组存储空间

## 非局部名字的访问
1. 无过程嵌套的静态作用域
	1. 过程体中的非局部引用可以直接使用静态确定的地址(非局部数据此时就是全局数据)
	2. 无须深入栈中取数据,无须访问链
2. 有过程嵌套的静态作用域
	1. 通过访问链访问非局部引用：二元组 ($n_p-n_a$，a在活动记录中的偏移)
	2. 访问链的建立：
		1. $n_p<n_x$ 的情况：要么 x 声明在 p 内；要么 x 不声明在 p 内，但也嵌套声明，那么不能被 p 调用；**所以 x 必定声明在 p 内**
		2. $n_p>n_x$ 的情况：**根据作用域规则**，这时 p 和 x 的嵌套深度分别为 1,2,...,$n_x$-1 的外围过程肯定相同
			+ 追踪访问链 $n_p-n_x$+1 次,到达了静态包围 x 和 p 的且离它们最近的那个过程的最新活动记录
			+ 所到达的活动记录就是x的活动记录中的访问链应该指向的那个活动记录

## 参数传递
1. 根据所传递的实参的“内容”,参数传递可分为:
	+ 传值调用:传递实参的右值到形参单元;
	+ 引用调用:传递实参的左值到形参单元;
	+ 换名调用:传递实参的“正文”。


