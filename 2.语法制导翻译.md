# 语法制导翻译
1. 综合属性 vs. 继承属性：P110
2. **S属性定义**：仅仅使用综合属性的语法制导定义成为 S 属性定义，P111
3. 注释分析树：P111
4. <font color=orange size=4>**（对于 L 属性定义）自下而上和自上而下的区别：**</font>以 $R->+T\{print('+');\}R_1$ 为例
	1. 自下而上时，在前缀为 $+T$ 时，不知道该不该继承，因为还不知道是按哪个产生式规约，甚至要继承当前栈顶文法符号的下一个文法符号 $R_1$ 都没有出现/确定；
	2. 自上而下时，在前缀为 $+T$ 时，完全已经知道当前状态是按该产生式递归来的，所以可以直接继承

## S属性定义的自下而上计算
### &nbsp;&nbsp;1. 语法树
1. 定义：P115
2. 构造语法树的语法制导定义
	1. **分析树与语法树的关系图示**（即 “构造语法树的语法制导定义” 的意义）：P116 例4.6
	2. 语法制导定义**实际执行的函数：**P117 黄线部分

### &nbsp;&nbsp;2. S属性的自下而上计算（具体栈实现）
1. S属性定义的翻译器可以借助 **LR分析器** 的生成器来实现


## L属性定义的自上而下计算（P119）
1. 语法制导定义是 L 属性的，如果对于产生式 $A->X_1X_2···X_n$ 
	1. 只计算 A 的综合属性
	2. 或者计算 $X_j$ 的继承属性只依赖：
		1. $X_j$ 左边符号的属性; 
        2. 或者 A 的继承属性
2. **分析树与语法树的关系图示**（即 “构造语法树的语法制导定义” 的意义）：P123 例4.10
3. **消除左递归为什么会产生继承属性?：**P124 星号部分

#### &nbsp;&nbsp;预测分析器的设计（P124)
1. A 的每个继承属性声明为该函数的一个形式参数
2. A 的综合属性作为他的返回值
3. A 产生式中的其他每个文法符号的每个属性声明一个局部变量

## L属性定义的自下而上计算（P127)
1. **标记非终结符 M：**P127 & P129 & 这份笔记的开头第 5 点
2. 分析器的属性计算都实现为**栈操作**